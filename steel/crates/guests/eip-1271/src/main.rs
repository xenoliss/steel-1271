// Copyright 2024 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use alloy_primitives::{Address, Bytes, B256};
use alloy_sol_types::sol;
use borsh::BorshSerialize;
use revm::primitives::SpecId;
use risc0_steel::{config::ChainSpec, ethereum::EthEvmInput, Contract};
use risc0_zkvm::guest::env;

#[derive(Debug, BorshSerialize, Clone, Hash)]
pub struct Journal {
    pub block_hash: [u8; 32],
    pub wallet: [u8; 32],
    pub hash: [u8; 32],
}

sol! {
    interface IERC1271 {
        function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 result);
    }
}

fn main() {
    // Read the input from the guest environment.
    let input: EthEvmInput = env::read();
    let wallet: Address = env::read();
    let hash: B256 = env::read();
    let signature: Bytes = env::read();

    // Converts the input into a `EvmEnv` for execution. The `with_chain_spec` method is used
    // to specify the chain configuration. It checks that the state matches the state root in the
    // header provided in the input.
    let env = input
        .into_env()
        .with_chain_spec(&ChainSpec::new_single(31337, SpecId::CANCUN));

    // Execute the view call; it returns the result in the type generated by the `sol!` macro.
    let call = IERC1271::isValidSignatureCall { hash, signature };
    let result = Contract::new(wallet, &env)
        .call_builder(&call)
        .call()
        .result;

    // Check that the magic value is returned.
    assert!(result == [0x16, 0x26, 0xba, 0x7e]);

    // Commit the block hash and number used when deriving `view_call_env` to the journal.
    let journal = Journal {
        block_hash: env.into_commitment().digest.into(),
        wallet: wallet.into_word().into(),
        hash: hash.into(),
    };

    journal.serialize(&mut env::journal()).unwrap();
}
